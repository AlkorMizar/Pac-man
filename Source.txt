 /*
                // Создание теневогоs контекста для двойной буфферизации
                hCmpDC = CreateCompatibleDC(hdc);
                hBmp = CreateCompatibleBitmap(hdc, Rect.right - Rect.left,
                    Rect.bottom - Rect.top);
                SelectObject(hCmpDC, hBmp);

                // Закраска фоновым цветом
                LOGBRUSH br;
                br.lbStyle = BS_SOLID;
                br.lbColor = 0x0;
                HBRUSH brush;
                brush = CreateBrushIndirect(&br);
                FillRect(hCmpDC, &Rect, brush);
                DeleteObject(brush);

                // Здесь рисуем на контексте hCmpDC

                // Копируем изображение из теневого контекста на экран
                SetStretchBltMode(hdc, COLORONCOLOR);
                BitBlt(hdc, elementSize::COIN_WIDTH + 50, 0, Rect.right - Rect.left, Rect.bottom - Rect.top,
                    hCmpDC, 0, 0, SRCCOPY);

                // Удаляем ненужные системные объекты
                DeleteDC(hCmpDC);
                DeleteObject(hBmp);
                hCmpDC = NULL;
        #define t 27
                // Создание теневогоs контекста для двойной буфферизации
                hCmpDC = CreateCompatibleDC(hdc);
                hBmp = CreateCompatibleBitmap(hdc, t-1,t-1);
                SelectObject(hCmpDC, hBmp);

                // Закраска фоновым цветом

                br.lbStyle = BS_SOLID;
                br.lbColor = frameContext::BLUE_COLOR;
                brush = CreateBrushIndirect(&br);
                Rect.left = 0;
                Rect.right = t;
                Rect.top = 0;
                Rect.bottom = t;

                FillRect(hCmpDC, &Rect, brush);
                DeleteObject(brush);

                BitBlt(hdc, 300,0 ,t, t,
                    hCmpDC, 0, 0, SRCCOPY);

                for (size_t i = 0; i < 29; i++)
                {
                    BitBlt(hdc, 300+8 , i * t , 9, t,
                        hCmpDC, 0, 0, SRCCOPY);
                }
                for (size_t i = 0; i < 29; i++)
                {
                    BitBlt(hdc, 300 + i * t, t * 2+8, t,9,
                        hCmpDC, 0, 0, SRCCOPY);
                }
                for (size_t i = 0; i < 29; i++)
                {
                    BitBlt(hdc, 300 + i * t , 8, t, 9,
                        hCmpDC, 0, 0, SRCCOPY);
                }
                // Копируем изображение из теневого контекста на экран

                // Удаляем ненужные системные объекты
                DeleteDC(hCmpDC);
                DeleteObject(hBmp);

                {

                    FrameRender render = FrameRender(hWnd, hInstance,currentGameContext);
                    auto sp = render.pink;
                    BitBlt(hdc, 300 + t + 14 - sp.width / 2, t + 14 - sp.height / 2, sp.width, sp.height,
                        sp.hdc, 0, 0, SRCCOPY);
                }

                /*
                hBmp = (HBITMAP)LoadImage(hInstance, TEXT("superCoin.bmp"), IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
                if (hBmp == NULL) {
                    return false;
                }
                BITMAP bm;
                GetObject(hBmp, sizeof(bm), &bm);
                hCmpDC = CreateCompatibleDC(hdc);
                SelectObject(hCmpDC, hBmp);
                DeleteObject(hBmp);*/
        mainDC = BeginPaint(hWnd, &ps);
        frameRender->renderText();
 /* {
            currentGameContext.setGameState(GameState::START_PALING);

            hdc = CreateCompatibleDC(mainDC);
            int width = frameContext::BORDER_RIGHT - frameContext::BORDER_LEFT;
            int height = frameContext::BORDER_BOTTOM - frameContext::BORDER_TOP;
            HBITMAP hBmp = CreateCompatibleBitmap(mainDC, width, height);
            SelectObject(hdc, hBmp);

            LOGBRUSH br;
            br.lbStyle = BS_SOLID;
            br.lbColor = 0x0;
            HBRUSH brush;
            brush = CreateBrushIndirect(&br);
            RECT Rect = { 0 ,0,width,width };
            FillRect(hdc, &Rect, brush);
            DeleteObject(brush);

            HPEN  pen = CreatePen(PS_SOLID, 3, frameContext::BLUE_COLOR);
            SelectObject(hdc, pen);
            for (size_t i = 1; i < mazeSize::ROWS_IN_MAZE; i++)
            {
                for (size_t j = 1; j < mazeSize::COLUMS_IN_MAZE; j++)
                {
                    if (currentGameContext.map[i][j] == ObjID::PATH) {
                        if (currentGameContext.map[i - 1][j] == ObjID::WALL) {
                            int x1 = j * frameContext::TILE_SIZE + frameContext::TILE_DELTA;
                            int x2 = x1 + frameContext::TILE_DELTA;

                            int y1 = i * frameContext::TILE_SIZE - frameContext::TILE_DELTA;
                            int y2 = y1;
                            x1 += currentGameContext.map[i - 1][j - 1] == ObjID::WALL ? -frameContext::TILE_DELTA * 2 : 0;
                            x2 += currentGameContext.map[i - 1][j + 1] == ObjID::WALL ? +frameContext::TILE_DELTA * 2 : 0;
                            MoveToEx(hdc, x1, y1, NULL);
                            LineTo(hdc, x2, y2);
                        }

                        if (currentGameContext.map[i + 1][j] == ObjID::WALL) {
                            int x1 = j * frameContext::TILE_SIZE + frameContext::TILE_DELTA;
                            int x2 = x1 + frameContext::TILE_DELTA;

                            int y1 = (i + 1) * frameContext::TILE_SIZE + frameContext::TILE_DELTA;
                            int y2 = y1;
                            x1 += currentGameContext.map[i + 1][j - 1] == ObjID::WALL ? -frameContext::TILE_DELTA * 2 : 0;
                            x2 += currentGameContext.map[i + 1][j + 1] == ObjID::WALL ? +frameContext::TILE_DELTA * 2 : 0;
                            MoveToEx(hdc, x1, y1, NULL);
                            LineTo(hdc, x2, y2);
                        }

                        if (currentGameContext.map[i][j - 1] == ObjID::WALL) {
                            int x1 = j * frameContext::TILE_SIZE - frameContext::TILE_DELTA;
                            int x2 = x1;

                            int y1 = i * frameContext::TILE_SIZE + frameContext::TILE_DELTA;
                            int y2 = y1 + frameContext::TILE_DELTA;
                            y1 += currentGameContext.map[i - 1][j - 1] == ObjID::WALL ? -frameContext::TILE_DELTA * 2 : 0;
                            y2 += currentGameContext.map[i + 1][j - 1] == ObjID::WALL ? +frameContext::TILE_DELTA * 2 : 0;
                            MoveToEx(hdc, x1, y1, NULL);
                            LineTo(hdc, x2, y2);
                        }

                        if (currentGameContext.map[i][j + 1] == ObjID::WALL) {
                            int x1 = (j + 1) * frameContext::TILE_SIZE + frameContext::TILE_DELTA;
                            int x2 = x1;

                            int y1 = i * frameContext::TILE_SIZE + frameContext::TILE_DELTA;
                            int y2 = y1 + frameContext::TILE_DELTA;
                            y1 += currentGameContext.map[i - 1][j + 1] == ObjID::WALL ? -frameContext::TILE_DELTA * 2 : 0;
                            y2 += currentGameContext.map[i + 1][j + 1] == ObjID::WALL ? +frameContext::TILE_DELTA * 2 : 0;
                            MoveToEx(hdc, x1, y1, NULL);
                            LineTo(hdc, x2, y2);
                        }
                    }
                }
            }
            
            DeleteObject(pen);
            ReleaseDC(hWnd, mainDC);
        }*/
        currentGameContext.setGameState(GameState::START_PALING);
        frameRender->reloadMap();
       // BitBlt(mainDC, frameContext::BORDER_LEFT, 0, frameRender->map.width, frameRender->map.height,
       //     frameRender->map.hdc, 0, 0, SRCCOPY);
        frameRender->renderNextFrame();
